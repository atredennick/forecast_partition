setwd("~/Repos/CEID_Forecasting")
knitr::opts_chunk$set(echo = TRUE)
source("src/updated_general_functions.R")
source("src/analogs_function.R")
library(dplyr)
library(forecast)
library(magrittr)
library(ggplot2)
library(reshape)
data <- read.csv("/Users/spencerhall/Desktop/RCode/DrakeLab/MetaAnalysis/flu.csv") %>%
select(., City.Name, State, Year, Week.Number, P, I) %>%
mutate(., PI = P + I) %>%
select(., -P, -I)
source("src/updated_general_functions.R")
source("src/analogs_function.R")
library(dplyr)
library(forecast)
library(magrittr)
library(ggplot2)
library(reshape)
data <- read.csv("data/flu.csv") %>%
select(., City.Name, State, Year, Week.Number, P, I) %>%
mutate(., PI = P + I) %>%
select(., -P, -I)
# First, I take some time
# series data from the CDC
# influenza dataset we have.
# This is the 2005 / 2006
# influenza season in
# San Antonio.
s <- c(14, 15, 13, 11, 11,
12, 21, 10, 12, 12,
13, 10, 14, 12, 17,
27, 22, 43, 22, 20,
21, 18, 32, 28, 37)
train <- s[1:20]
test <- s[21:25]
# Now I fit an ARIMA model to the
# training set using general_fit(),
# and compare with the testing
# set.
best_q <- 2
pred <- general_fit(train = train,
model_type = "auto.arima",
n = 6)
# Note that I use pred$mean and not
# just pred. This is because pred is
# a forecast object and as such has
# several associated values, including
# various confidence bounds. The
# mean value is what is usually
# used for the predicted value.
compare <- data.frame(t = 21:25,
"Real Values" = test,
"Predicted" = pred$mean) %>%
melt(., id = "t")
pred$mean
test
best_q <- 2
pred <- general_fit(train = train,
model_type = "auto.arima",
n = 5)
# Note that I use pred$mean and not
# just pred. This is because pred is
# a forecast object and as such has
# several associated values, including
# various confidence bounds. The
# mean value is what is usually
# used for the predicted value.
compare <- data.frame(t = 21:25,
"Real Values" = test,
"Predicted" = pred$mean) %>%
melt(., id = "t")
ggplot(data = compare, aes(x = t, y = value, colour = variable)) +
geom_point() + geom_line() +
ggtitle("ARIMA Prediction With general_fit() Function")
best_q <- 10
suppressWarnings(arima_pred_plot <- predict_and_plot(pi_vec = s, model_type = "auto.arima",
k = 15,
with_bar = FALSE, "max.q = best_q"))
arima_pred_plot + ggtitle("predict_and_plot() - ARIMA")
start_year <- 2005
suppressWarnings(analogs_pred_plot <- predict_and_plot(pi_vec = s, model_type = "get_analogs",
k = 15,
with_bar = FALSE, "start_year", "data"))
analogs_pred_plot + ggtitle("predict_and_plot() - Analogs")
source("~/Desktop/RCode/DrakeLab/Analogs/updated_general_functions.R")
# source("~/Desktop/RCode/DrakeLab/Analogs/updated_general_functions.R")
# source("~/Desktop/RCode/DrakeLab/Analogs/analogs_function.R")
best_q <- 10
suppressWarnings(arima_with_noise <- predict_with_noise(pi_vec = s, model_type = "auto.arima",
steps_ahead = 5,
sigma = 2, seed = 1995, "max.q = best_q"))
arima_with_noise + ggtitle("predict_with_noise() - ARIMA")
start_year <- 2005
suppressWarnings(analogs_with_noise <- predict_with_noise(pi_vec = s, model_type = "get_analogs",
steps_ahead = 5, sigma = 2,
seed = 1995, "start_year", "data"))
analogs_with_noise + ggtitle("predict_with_noise() - Analogs")
pred_values <- vector()
res <- vector()
suppressWarnings(arima_cv <- ts_cv(pi_vec = s, train_length = 15, model_type = "auto.arima", k = 1,
type = "exp_fixed_k", change_by = NULL, type_transform = "none"))
arima_cv + ggtitle("Rolling Cross-Validation - ARIMA")
pred_values <- vector()
res <- vector()
suppressWarnings(analogs_cv <- ts_cv(pi_vec = s, train_length = 15, model_type = "get_analogs", k = 1,
type = "exp_fixed_k", change_by = NULL, type_transform = "none",
"start_year", "data"))
analogs_cv + ggtitle("Rolling Cross-Validation - Analogs")
################################################################################
##  generate_forecast_fxns.R: Script to generate a forecast time series.
##  The simulated data can then be used to test the forecast partitioning
##  approach. The forecast generation process includes error from
##  initial conditions uncertainty, parameter error, driver uncertainty, and
##  process error.
##
##  Author: Andrew Tredennick
##  Date created: March 13, 2018
################################################################################
##  Clear the workspace
rm(list = ls(all.names = TRUE))
####
####  LOAD LIBRARIES -----------------------------------------------------------
####
library(tidyverse)
library(dplyr)
library(ggthemes)
####
####  DEFINE SIMULATOR FUNCTION ------------------------------------------------
####
generate_forecast <- function(z_bar,
z_sigma,
a_bar,
a_sigma,
theta_bar = NULL,
theta_sigma = NULL,
x_bar = NULL,
x_sigma = NULL,
proc_sigma,
n_times,
n_iters,
seed = NULL){
if(is.null(seed) == FALSE){
set.seed(seed)
}
if(is.null(x_bar) == FALSE){
if(is.matrix(x_bar) == FALSE){
stop("x_bar must be a matrix even if only providing one covariate.
Coerce to a single column matrix, with the number of rows equal
to the number of time steps to be forecast.")
}
if((ncol(x_bar)-1) != length(theta_bar)){
stop("The number of covariates [ncol(x_bar)] and the number of
coefficients [length(theta_bar)] do not match.")
}
}
# Generate vector of initial conditions
Z <- rnorm(n_iters, z_bar, z_sigma)
# Generate vector of autoregressive terms
A <- rnorm(n_iters, a_bar, a_sigma)
# Generate array of time-varying covariates
if(is.null(x_bar) == FALSE){
X <- array(NA, dim = c((ncol(x_bar)+1), n_iters, n_times))
X[1,,] <- 1 # make first rows 1 for the intercept
for(dot in 1:n_times){
for(dox in 1:ncol(x_bar)){
X[dox+1,,dot] <- rnorm(n_iters, x_bar[dot,dox], x_sigma[dot,dox])
}
}
}
# Generate matrix of time-invariant parameters
if(is.null(theta_bar) == FALSE){
Theta <- matrix(NA, length(theta_bar), n_iters)
for(dotheta in 1:length(theta_bar)){
Theta[, dotheta] <- rnorm(n_iters, theta_bar[dotheta], theta_sigma[dotheta])
}
}
# Generate matrix of forecasts
forecasts <- matrix(NA, n_times+1, n_iters)
forecasts[1,] <- Z
if(is.null(theta_bar)){
for(iiter in 1:n_times){
Z <- A*Z
forecasts[iiter+1, ] <- rnorm(n_iters, Z, proc_sigma)
}
}else{
for(iiter in 1:n_times){
mu <- A*Z[iiter] + X[iiter, ]*Theta
forecasts[iiter, ] <- rnorm(n_iters, mu, proc_sigma)
}
}
return(forecasts)
}
####
####  GENERATE FORECASTS -------------------------------------------------------
####
z_bar <- -20
z_sigma <- 1.5
a_bar <- 0.8
a_sigma <- 0.1
proc_sigma <- 1.6
n_times <- 10
n_iters <- 100
seed <- 126
outcasts_all <- generate_forecast(z_bar,
z_sigma,
a_bar,
a_sigma,
theta_bar = NULL,
theta_sigma = NULL,
x_bar = NULL,
x_sigma = NULL,
proc_sigma,
n_times,
n_iters,
seed)
outcasts_noproc <- generate_forecast(z_bar,
z_sigma,
a_bar,
a_sigma,
theta_bar = NULL,
theta_sigma = NULL,
x_bar = NULL,
x_sigma = NULL,
proc_sigma = 0,
n_times,
n_iters,
seed)
outcasts_noparam <- generate_forecast(z_bar,
z_sigma,
a_bar,
a_sigma = 0,
theta_bar = NULL,
theta_sigma = NULL,
x_bar = NULL,
x_sigma = NULL,
proc_sigma,
n_times,
n_iters,
seed)
outcasts_noinit <- generate_forecast(z_bar,
z_sigma = 0,
a_bar,
a_sigma,
theta_bar = NULL,
theta_sigma = NULL,
x_bar = NULL,
x_sigma = NULL,
proc_sigma,
n_times,
n_iters,
seed)
outcasts_combined <- as.data.frame(outcasts_all) %>%
mutate(year = 0:n_times) %>%
gather(key,value,-year) %>%
mutate(simulation = "A) All sources") %>%
rbind(as.data.frame(outcasts_noproc) %>%
mutate(year = 0:n_times) %>%
gather(key,value,-year) %>%
mutate(simulation = "D) No process error")) %>%
rbind(as.data.frame(outcasts_noinit) %>%
mutate(year = 0:n_times) %>%
gather(key,value,-year) %>%
mutate(simulation = "B) No initial conditions error")) %>%
rbind(as.data.frame(outcasts_noparam) %>%
mutate(year = 0:n_times) %>%
gather(key,value,-year) %>%
mutate(simulation = "C) No parameter error"))
ggplot(outcasts_combined, aes(x = year, y = value, group = key))+
geom_line(color = "darkgrey", alpha = 0.8)+
facet_wrap(~simulation, ncol = 4)+
scale_x_continuous(breaks = c(0,2,4,6,8,10))+
ylab("State")+
xlab("Forecast year")+
theme_few()+
theme(axis.text.y = element_blank())
ggplot(outcasts_combined, aes(x = year, y = value, group = key))+
geom_line(color = "darkgrey", alpha = 0.8)+
facet_wrap(~simulation, ncol = 4)+
scale_x_continuous(breaks = c(0,2,4,6,8,10))+
ylab("State of interest")+
xlab("Forecast year")+
theme_few()+
theme(axis.text.y = element_blank())
setwd("~/Repos/forecast_partition/code")
ggsave(filename = "../figures/forecast_uncertainty_example.pdf", width = 8.5, height = 3, units = "in")
